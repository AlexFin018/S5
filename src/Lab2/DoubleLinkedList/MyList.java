package Lab2.DoubleLinkedList;

import Common.InvalidPositionException;

/**
 * Класс реализует функциональность АТД Список на двусвязном списке
 */
public class MyList {
    /**
     * Ссылка на элемент в первой позиции списка
     */
    private Node head = null;
    /**
     * Ссылка на элемент в последней позиции списка
     */
    private Node tail = null;

    /**
     * Метод возвращает позицию первого элемента или end() если список пустой
     * @return позиция первого элемента, или позиция после последнего
     */
    public Position first() {
        //Если список пустой, то вернем позицию после последнего
        //Иначе возвращаем позицию со ссылкой на первый элемент
        return new Position(head);
    }
    /**
     * Метод возвращает позицию после последнего элемента
     * @return позиция после последнего элемента
     */
    public Position end() {
        //Вернем позицию со ссылкой равной null
        return new Position(null);
    }
    /**
     * Возвращает позицию следующего элемента в списке или end(), если нет следующего элемента
     * @param p позиция текущего элемента
     * @return позиция следующего элемента
     */
    public Position next(Position p){
        // Проверим позицию на корректность
        checkPosition(p,true);
        //Вернем позицию со ссылкой на следующий элемент
         return new Position(p.link.nextNode);
    }
    /**
     * Метод возвращает позицию предыдущего элемента в списке или end()
     * @param p позиция текущего элемента
     * @return позиция предыдущего элемента
     */
    public Position previous(Position p){
        //Если список пустой или позиция не указана, то выкинем ошибку
        checkPosition(p,true);
        //Вернем позицию со ссылкой на предыдущий элемент
        return new Position(p.link.prevNode);
    }
    /**
     * Метод возвращает элемент в указанной позиции
     * @param p - позиция элемента
     * @return искомый элемент
     */
    public Node retrieve(Position p){
        // Если позиция некорректная, выкинем ошибку
        checkPosition(p,true);
        // возвращаем ссылку на элемент, которая указана в позиции
        return p.link;
    }
    /**
     * Метод удаляет элемент в указанной позиции
     * @param p позиция для удаления элемента
     */
    public void delete(Position p){
        // Если список пустой или не указана позиция или это позиция за последним
        checkPosition(p,true);
        //Если это первая позиция, то переустанавливаем head на элемент,
        // следующий за удаляемым, и у этого элемента обнуляем ссылку на предыдущий элемент
        if(head == p.link){
            head = p.link.nextNode;
            if(head != null) head.prevNode = null;
            else {
                //Если head стал null, значит удалили последний элемент и нужно обнулить tail
                tail = null;
            }
            //Устанавливаем p на после последней
            p.link = null;
        }
        // Если это последний, то переустанавливаем tail на элемент, предшествующий удаляемому,
        // у этого элемента ссылку на следующий устанавливаем в null
        else if(tail == p.link){
            // В данном месте всегда есть предыдущий, т.е. tail не может стать null,
            // при отсутствии предыдущего элемента мы попадаем на удаление первого элемента

            tail = p.link.prevNode;
            tail.nextNode = null;
            //Устанавливаем p на после последней
            p.link = null;
        }
        // Если это не начало и конец, то выкидываем элемент из цепочки
        else {
            p.link.prevNode.nextNode = p.link.nextNode;
            p.link.nextNode.prevNode = p.link.prevNode;
            //Устанавливаем данные удаленной позиции на след позицию
            p.link = p.link.nextNode;
        }
    }

    /**
     * Метод проверяет позицию на существование
     * @param p позиция для проверки
     */
    private void checkPosition(Position p,boolean mustExist){
        //Если допускается позиция после последней, то проверим и вернемся
        if(!mustExist){
            if(p.link == null) return;
        }
        // Проверим позицию на существование. В цикле переберем все позиции и сравним со всеми
        Node s = head;
        while(s != null){
            if(p.link == s) return; // Если находим то выходим
            s = s.nextNode;
        }
        //Если не нашли, то ругаемся
        throw new InvalidPositionException();
    }

    /**
     * Очищает список элементов и возвращает end()
     * @return позицию после последнего
     */
    public Position makeNull() {
        // Обнулить head и tail
        head = tail = null;
        // Вернуть позицию после последнего
        return new Position(null);
    }

    /**
     * Метод находит в списке позицию первого элемента равного указанному
     * @param x элемент для поиска
     * @return позиция найденного элемента, или позиция после последнего, если она не найдена
     */
    public Position locate(Node x){
        //цикл начинается с первого элемента списка (указанного
        // переменной head) и проходит по списку, проверяя каждый элемент:
        //переменная l в каждой итерации обновляется ссылкой на следующий элемент,
        // используя поле nextElement у текущего элемента.
        //Для каждого элемента списка вызывается метод equals(), чтобы проверить,
        // совпадает ли текущий элемент с искомым элементом x
        //Если метод equals() возвращает true, то найдено совпадение, и метод
        // возвращает позицию, указывающую на текущий элемент l
        //Если после завершения цикла элемент так и не был найден, то метод возвращает позицию
        // после последнего элемента
        Node current = head;
        while(current != null && ! current.equals(x)){
            current = current.nextNode;
        }
        return new Position(current);
    }

    /**
     * Вставляет элемент в указанную позицию, при этом в указанной позиции
     * оказывается добавленный элемент. Элемент бывший в этой позиции становится следующим за
     * этой позицией
     * @param le - вставляемый элемент
     * @param p - позиция, в которую ставится элемент
     */
    public void insert(Node le, Position p){
        // Проверяем позицию на корректность
        checkPosition(p,false);

        Node x = new Node(le); // Будем вставлять копию
        //Если p - это после последней, то ставим в конец
        if(p.link == null){
            // Заносим в позицию ссылку на вставляемый элемент
            p.link = x;
            // Если список пустой, то head и tail устанавливаем на этот элемент
            if(head == null){
                head = tail = x;
            }
            // Иначе
            else {
                // Устанавливаем в последнем элементе в списке nextElement равным ссылке на
                // вставляемый элемент
                tail.nextNode = x;
                // Устанавливаем в добавленном элементе prevElement на tail
                x.prevNode = tail;
                //Устанавливаем последний в списке на добавленный элемент
                tail = x;
            }
        }
        // Если это не последняя позиция, то
        // вставляем элемент в цепочку, при этом старый элемент в этой позиции становится
        // следующим
        else {
            if(head == p.link) head = x; //Если это был head, то обновим head
            p.link.prevNode = x;
            x.nextNode = p.link;
            p.link = x;
        }
    }
    /**
     * Метод печатает список элементов
     */
    public void printList(){
        //цикл от первого элемента списка, пока l не станет равен null
        // В каждой итерации l обновляется ссылкой на следующий элемент в списке: l.nextElement
        //Для каждого элемента списка метод выводит на консоль имя и адрес
        for(Node p = head; p!=null; p = p.nextNode){
            p.PrintElement();
            System.out.println();
        }
    }
}
