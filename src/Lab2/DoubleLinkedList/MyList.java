package Lab2.DoubleLinkedList;

import Common.InvalidPositionException;

/**
 * Класс реализует функциональность АТД Список на двусвязном списке
 */
public class MyList {
    /**
     * Ссылка на элемент в первой позиции списка
     */
    private ListElement head = null;
    /**
     * Ссылка на элемент в последней позиции списка
     */
    private ListElement tail = null;

    /**
     * Метод возвращает позицию первого элемента или end() если список пустой
     * @return позиция первого элемента, или позиция после последнего
     */
    public Position first() {
        //Если список пустой, то вернем позицию после последнего
        if(head == null) return new Position(null);
        //Иначе возвращаем позицию со ссылкой на первый элемент
        return new Position(head);
    }
    /**
     * Метод возвращает позицию после последнего элемента
     * @return позиция после последнего элемента
     */
    public Position end() {
        //Вернем позицию со ссылкой равной null
        return new Position(null);
    }
    /**
     * Возвращает позицию следующего элемента в списке или end(), если нет следующего элемента
     * @param p позиция текущего элемента
     * @return позиция следующего элемента
     */
    public Position next(Position p){
        // Проверим позицию на корректность
        checkPosition(p);
        //Вернем позицию со ссылкой на следующий элемент
         return new Position(p.link.nextElement);
    }
    /**
     * Метод возвращает позицию предыдущего элемента в списке или end()
     * @param p позиция текущего элемента
     * @return позиция предыдущего элемента
     */
    public Position previous(Position p){
        //Если список пустой или позиция не указана, то выкинем ошибку
        checkPosition(p);
        // Если это позиция первого элемента, или в позиции по каким-то причинам нет ссылки на
        // предыдущий элемент выкинем ошибку
        if(head == p.link || p.link.prevElement == null) throw new InvalidPositionException();
        //Вернем позицию со ссылкой на предыдущий элемент
        return new Position(p.link.prevElement);
    }
    /**
     * Метод возвращает элемент в указанной позиции
     * @param p - позиция элемента
     * @return искомый элемент
     */
    public ListElement retrieve(Position p){
        // Если позиция некорректная, выкинем ошибку
        checkPosition(p);
        // возвращаем ссылку на элемент, которая указана в позиции
        return p.link;
    }
    /**
     * Метод удаляет элемент в указанной позиции
     * @param p позиция для удаления элемента
     */
    public void delete(Position p){
        // Если список пустой или не указана позиция или это позиция за последним
        checkPosition(p);
        //Если это первая позиция, то переустанавливаем head на элемент,
        // следующий за удаляемым, и у этого элемента обнуляем ссылку на предыдущий элемент
        if(head == p.link){
            head = p.link.nextElement;
            if(head != null) head.prevElement = null;
            else {
                //Если head стал null, значит удалили последний элемент и нужно обнулить tail
                tail = null;
            }
            //Устанавливаем p на после последней
            p.link = null;
        }
        // Если это последний, то переустанавливаем tail на элемент, предшествующий удаляемому,
        // у этого элемента ссылку на следующий устанавливаем в null
        else if(tail == p.link){
            // В данном месте всегда есть предыдущий, т.е. tail не может стать null,
            // при отсутствии предыдущего элемента мы попадаем на удаление первого элемента

            tail = p.link.prevElement;
            tail.nextElement = null;
            //Устанавливаем p на после последней
            p.link = null;
        }
        // Если это не начало и конец, то выкидываем элемент из цепочки
        else {
            p.link.prevElement.nextElement = p.link.nextElement;
            p.link.nextElement.prevElement = p.link.prevElement;
            //Устанавливаем данные удаленной позиции на след позицию
            p.link = p.link.nextElement;
        }
    }

    /**
     * Метод проверяет позицию на существование
     * @param p позиция для проверки
     */
    private void checkPosition(Position p){
        // Если список пустой или не указана позиция или это позиция за последним
        if(head == null || p == null || p.link == null) throw new InvalidPositionException();
    }

    /**
     * Очищает список элементов и возвращает end()
     * @return позицию после последнего
     */
    public Position makeNull() {
        //Достаточно удалить ссылки в одну сторону и начальную ссылку,
        // чтобы сборщик мусора быстро уничтожил остальное
        for(ListElement e = head; e != null; e = e.nextElement){
            e.prevElement = null;
        }
        // Но главное - обнулить head и tail
        head = tail = null;
        // Вернуть позицию после последнего
        return new Position(null);
    }

    /**
     * Метод находит в списке позицию первого элемента равного указанному
     * @param x элемент для поиска
     * @return позиция найденного элемента, или позиция после последнего, если она не найдена
     */
    public Position locate(ListElement x){
        //цикл начинается с первого элемента списка (указанного
        // переменной head) и проходит по списку, проверяя каждый элемент:
        //переменная l в каждой итерации обновляется ссылкой на следующий элемент,
        // используя поле nextElement у текущего элемента.
        //Для каждого элемента списка вызывается метод equals(), чтобы проверить,
        // совпадает ли текущий элемент с искомым элементом x
        //Если метод equals() возвращает true, то найдено совпадение, и метод
        // возвращает позицию, указывающую на текущий элемент l
        //Если после завершения цикла элемент так и не был найден, то метод возвращает позицию
        // после последнего элемента
        for (ListElement p = head; p != null; p = p.nextElement) {
            if(p.equals(x)) return new Position(p);
        }
        return new Position(null);
    }

    /**
     * Вставляет элемент в указанную позицию, при этом в указанной позиции
     * оказывается добавленный элемент. Элемент бывший в этой позиции становится следующим за
     * этой позицией
     * @param le - вставляемый элемент
     * @param p - позиция, в которую ставится элемент
     */
    public void insert(ListElement le, Position p){
        ListElement x = new ListElement(le); // Будем вставлять копию
        // Проверяем позицию на корректность
        if(p == null) throw new InvalidPositionException();
        //Если p - это после последней, то ставим в конец
        if(p.link == null){
            // Заносим в позицию ссылку на вставляемый элемент
            p.link = x;
            // Если список пустой, то head и tail устанавливаем на этот элемент
            if(head == null){
                head = tail = x;
            }
            // Иначе
            else {
                // Устанавливаем в последнем элементе в списке nextElement равным ссылке на
                // вставляемый элемент
                tail.nextElement = x;
                // Устанавливаем в добавленном элементе prevElement на tail
                x.prevElement = tail;
                //Устанавливаем последний в списке на добавленный элемент
                tail = x;
            }
        }
        //Если это первый элемент, то меняем head
        else if(head == p.link){
            // В head элементе устанавливаем prevElement на добавляемый элемент,
            head.prevElement = x;
            // В добавляемом элементе следующим ставим имеющийся head
            x.nextElement = head;
            // В указанной позиции устанавливаем ссылку на добавленный элемент
            p.link = x;
            //Устанавливаем head на добавленный элемент
            head = x;
        }
        // Если это не первая и не последняя позиция, то
        // вставляем элемент в цепочку, при этом старый элемент в этой позиции становится
        // следующим
        else {
            p.link.prevElement = x;
            x.nextElement = p.link;
            p.link = x;
        }
    }
    /**
     * Метод печатает список элементов
     */
    public void printList(){
        //цикл от первого элемента списка, пока l не станет равен null
        // В каждой итерации l обновляется ссылкой на следующий элемент в списке: l.nextElement
        //Для каждого элемента списка метод выводит на консоль имя и адрес
        for(ListElement p = head; p!=null; p = p.nextElement){
            p.PrintElement();
            System.out.println();
        }
    }
}
