package Lab2.DoubleLinkedList;

import Common.InvalidPositionException;

/**
 * Класс реализует функциональность АТД Список на двусвязном списке
 */
public class MyList {
    /**
     * Ссылка на элемент в первой позиции списка
     */
    private Node head = null;
    /**
     * Ссылка на элемент в последней позиции списка
     */
    private Node tail = null;

    /**
     * Метод возвращает позицию первого элемента или end() если список пустой
     * @return позиция первого элемента, или позиция после последнего
     */
    public Position first() {
        //Если список пустой, то вернем позицию после последнего
        //Иначе возвращаем позицию со ссылкой на первый элемент
        return new Position(head);
    }
    /**
     * Метод возвращает позицию после последнего элемента
     * @return позиция после последнего элемента
     */
    public Position end() {
        //Вернем позицию со ссылкой равной null
        return new Position(null);
    }
    /**
     * Возвращает позицию следующего элемента в списке или end(), если нет следующего элемента
     * @param p позиция текущего элемента
     * @return позиция следующего элемента
     */
    public Position next(Position p){
        // Если позиции не существует или это позиция после последней, то выкинем исключение
        if(!checkPosition(p)) throw new InvalidPositionException();
        //Вернем позицию со ссылкой на следующий элемент
         return new Position(p.link.nextNode);
    }
    /**
     * Метод возвращает позицию предыдущего элемента в списке или end()
     * @param p позиция текущего элемента
     * @return позиция предыдущего элемента
     */
    public Position previous(Position p){
        //Если позиции не существует, или это первая позиция
        // выкидываем исключение
        if(!checkPosition(p) || p.link == head) throw new InvalidPositionException();
        //Вернем позицию со ссылкой на предыдущий элемент
        return new Position(p.link.prevNode);
    }
    /**
     * Метод возвращает элемент в указанной позиции
     * @param p - позиция элемента
     * @return искомый элемент
     */
    public Node retrieve(Position p){
        // Если позиция не существует или это позиция после последней,
        // выкинем ошибку
        if(!checkPosition(p)) throw new InvalidPositionException();
        // возвращаем ссылку на элемент, которая указана в позиции
        return p.link;
    }
    /**
     * Метод удаляет элемент в указанной позиции
     * @param p позиция для удаления элемента
     */
    public void delete(Position p){
        // Если позиции не существует
        if(!checkPosition(p)) throw new InvalidPositionException();

        // 1. Если список пустой, то проверка позиции выкинет ошибку
        // 2. Если в списке один элемент, то p.link.nextElement и p.link.prevelement равны нулю,
        // после удаления должны обнулиться head, tail и p.link
        // head обнулится в строке 1, tail обнулится в строке 2, p.link обнулится в строке 3
        // 3. Общий случай - удаление из середины, выполнятся строки 4 и 5 и 3
        // 4. Удаление головы, выполнятся строки 1 и 5 и 3
        // 5. Удаление хвоста, выполнятся строки 4 и 2 и 3

        // Если удаляем head, то меняем head на следующий
        if(p.link == head) {
            head = p.link.nextNode; //1
        }
        else {
            //Иначе у предыдущего меняем следующий на следующего
            p.link.prevNode.nextNode = p.link.nextNode; //4
        }

        // Если удаляем tail, то меняем tail на предыдущий
        if(p.link == tail){
            tail = p.link.prevNode; // 2
        }
        else {
            //Иначе у следующего меняем предыдущий
            p.link.nextNode.prevNode = p.link.prevNode; //5
        }
        //Устанавливаем ссылку в позиции на следующий элемент
        p.link = p.link.nextNode; // 3
    }

    /**
     * Метод проверяет позицию на существование. Для позиции после последней выкидывается ошибка
     * @param p позиция для проверки
     * @return true, если позиция существует, false - если нет
     */
    private boolean checkPosition(Position p){
        // Проверим позицию на существование. В цикле переберем все позиции и сравним со всеми
        Node s = head;
        while(s != null){
            if(p.link == s) return true; // Если находим, то выходим с true
            s = s.nextNode;
        }
        //Если не нашли, то выходим с false
        return false;
    }

    /**
     * Очищает список элементов и возвращает end()
     * @return позицию после последнего
     */
    public Position makeNull() {
        // Обнулить head и tail
        head = tail = null;
        // Вернуть позицию после последнего
        return new Position(null);
    }

    /**
     * Метод находит в списке позицию первого элемента равного указанному
     * @param x элемент для поиска
     * @return позиция найденного элемента, или позиция после последнего, если она не найдена
     */
    public Position locate(Node x){
        //Цикл начинается с первого узла списка (указанного
        // переменной first) и проходит по списку, проверяя каждый узел:
        //переменная p в каждой итерации обновляется ссылкой на следующий узел,
        // используя поле next у текущего узла.
        //Для каждого узла списка вызывается метод equals(), чтобы проверить,
        // совпадает ли текущий узел с искомым элементом x
        //Если метод equals() возвращает true, то найдено совпадение, и метод
        // возвращает позицию, указывающую на текущий узел current
        //Если после завершения цикла элемент так и не был найден, то метод возвращает позицию
        // после последнего элемента
        Node current = head;
        while(current != null && ! current.equals(x)){
            current = current.nextNode;
        }
        return new Position(current);
    }

    /**
     * Вставляет элемент в указанную позицию, при этом в указанной позиции
     * оказывается добавленный элемент. Элемент бывший в этой позиции становится следующим за
     * этой позицией
     * @param le - вставляемый элемент
     * @param p - позиция, в которую ставится элемент
     */
    public void insert(Node le, Position p){
        // Если позиции не существует и это не позиция после последней, выкидываем ошибку
        if(p.link != null && !checkPosition(p)) throw new InvalidPositionException();

        Node x = new Node(le); // Будем вставлять копию
        //Если p - это после последней, то ставим в конец
        if(p.link == null){
            // Заносим в позицию ссылку на вставляемый элемент
            p.link = x;
            // Если список пустой, то head и tail устанавливаем на этот элемент
            if(head == null){
                head = tail = x;
            }
            // Иначе
            else {
                // Устанавливаем в последнем элементе в списке nextElement равным ссылке на
                // вставляемый элемент
                tail.nextNode = x;
                // Устанавливаем в добавленном элементе prevElement на tail
                x.prevNode = tail;
                //Устанавливаем последний в списке на добавленный элемент
                tail = x;
            }
            return;
        }
        // Если это не последняя позиция, то
        // вставляем элемент в цепочку, при этом старый элемент в этой позиции становится
        // следующим
        if(head == p.link) head = x; //Если это был head, то обновим head
        p.link.prevNode = x;
        x.nextNode = p.link;
        p.link = x;
    }

    /**
     * Метод печатает список элементов
     */
    public void printList(){
        //цикл от первого элемента списка, пока l не станет равен null
        // В каждой итерации l обновляется ссылкой на следующий элемент в списке: l.nextElement
        //Для каждого элемента списка метод выводит на консоль имя и адрес
        for(Node p = head; p!=null; p = p.nextNode){
            p.PrintElement();
            System.out.println();
        }
    }
}
