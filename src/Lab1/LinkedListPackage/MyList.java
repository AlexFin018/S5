package Lab1.LinkedListPackage;
import Common.InvalidPositionException;

/**
 * Класс реализации списка на связном списке
 *
 */
public class MyList {
    // Ссылка на первый элемент списка. Изначально
    // список пустой, поэтому first равен null
    private Node first = null;

    /**
     * Метод First возвращает позицию (Position) 1-го элемента в списке
     * Если список пустой --> возвращает позицию после последнего
     * @return первую позицию в списке
     */
    public Position first(){
        //Если first == null т.е. список пустой, то вернется позиция после последнего
        return new Position(first);
    }

    /**
     * Метод End возвращает позицию после последнего элемента в списке
     * @return позиция после последней
     */
    public Position end(){
        return new Position(null);
    }

    /**
     * Метод Next возвращает позицию следующего элемента в списке
     * @param p - текущая позиция в списке
     * @return позиция следующего элемента
     */
    public Position next(Position p){
        //Если позиция не существует, выкидывается исключение
        findPrevious(p);
        return new Position(p.link.nextNode);
    }

    /**
     * Метод возвращает позицию предыдущего элемента.
     * @param p - позиция, для которой надо найти предыдущий элемент
     * @return позиция предыдущего элемента
     */
    public Position previous(Position p){
        // Если это первая позиция, то выкидываем исключение
        if(p.link == first) throw new InvalidPositionException();
        //Остальные проверки в findPrevious.
        //Возвращает позицию предыдущего элемента.
        return findPrevious(p);
    }

    /**
     * Приватный метод, находит предыдущую позицию.
     * Для позиции после последней или несуществующей выкидывается исключение
     * Для первой позиции возвращается позиция после последней
     * @param p текущая позиция
     * @return предыдущая позиция
     */
    private Position findPrevious(Position p){

        // Устанавливаем current на начало списка, prev в null
        Node current = first,prev = null;
        // Пока текущий не равен null
        while(current != null){
            //Если текущий стал равен позиции из параметра, то возвращаем предыдущий
            if(current == p.link) return new Position(prev);
            // Запоминаем текущего в предыдущем
            prev = current;
            // переходим к следующему элементу
            current = current.nextNode;
        }
        // Если позиция не найдена, то выкидываем ошибку
        throw new InvalidPositionException();
    }


    /**
     * Метод Retrieve возвращает элемент списка по позиции
     * @param p позиция элемента
     * @return элемент в указанной позиции
     */
    public Node retrieve(Position p){
        //Возвращает элемент списка по заданной позиции.
        //Проверяется корректность позиции
        findPrevious(p);
        return p.link;
    }

    /**
     * Метод Delete удаляет элемент из позиции списка
     * @param p позиция, в которой нужно удалить элемент
     */
    public void delete(Position p){
        //Проверяется корректность позиции и находим предыдущий элемент
        Position previous =  findPrevious(p);

        //Удаляет элемент списка на позиции p.
        //Если удаляемый элемент — первый, то firstElement переходит
        //на следующий элемент.
        if(p.link == first) first = p.link.nextNode;
        //Если удаляемый элемент не является первым, нужно найти предыдущий
        // элемент. Для этого вызывается метод findPrevious(p).
        else {
            //После того как найден предыдущий элемент, его поле nextElement переназначается
            // так, чтобы оно указывало на элемент, следующий за удаляемым.
            previous.link.nextNode = p.link.nextNode;
        }

        // Переустанавливаем позицию на элемент, следующий за удаленным
        p.link = p.link.nextNode;
    }

    /**
     * Очищает список
     * @return позицию после последней
     */
    public Position makeNull(){
        //Очищает список, делая его пустым.
        //First становится равен нулю
        first = null;
        return new Position(null);
    }

    /**
     * Возвращает позицию в списке объекта x. Если объекта в списке нет, то возвращается позиция end().
     * Если несколько значений, совпадает со значением x, то возвращается первая позиция от начала
     * @param x объект для поиска
     * @return позиция первого найденного объекта в списке
     */
    public Position locate(Node x){
        //Цикл начинается с первого элемента списка (указанного
        // переменной firstElement) и проходит по списку, проверяя каждый элемент:
        //переменная l в каждой итерации обновляется ссылкой на следующий элемент,
        // используя поле nextElement у текущего элемента.
        //Для каждого элемента списка вызывается метод equals(), чтобы проверить,
        // совпадает ли текущий элемент с искомым элементом x
        //Если метод equals() возвращает true, то найдено совпадение, и метод
        // возвращает позицию, указывающую на текущий элемент l
        //Если после завершения цикла элемент так и не был найден, то метод возвращает позицию
        // после последнего элемента

        Node current = first;
        while(current != null && !current.equals(x)){
            current = current.nextNode;
        }
        return new Position(current);
    }

    /**
     * Метод вставляет элемент x на позицию p, элемент на позиции p становится следующим
     * @param le элемент, копию которого нужно вставить
     * @param p позиция для вставки
     */
    public void insert(Node le, Position p ){

        //Проверяется корректность позиции и находим предыдущую
        Position prev = null;
        // Если указана позиция после последней, то в качестве предыдущей ищем последний элемент
        if(p.link == null)
            prev = findTail();
        else
            prev =  findPrevious(p); // Иначе предыдущий

        Node x = new Node(le);
        //Если вставляем на первую позицию
        if(p.link == first){
            // У текущей позиции ставим следующего на первого в списке
            x.nextNode = first;
            // Первого в списке ставим на новый узел
            first = x;
            // В позиции меняем ссылку на занесенный элемент
            p.link = x;
            return;
        }
        // Если не первый, то у предыдущего ставим ссылку на новый узел
        prev.link.nextNode = x;
        // У нового узла ставим ссылку на тот узел, что сейчас находится в этой позиции
        x.nextNode = p.link;
        // В позиции меняем ссылку на заносимый узел
        p.link = x;
    }

    /**
     * Метод ищет позицию последнего элемента в спсике
     * @return позиция последнего элемента в списке
     */
    private Position findTail(){
        Node current = first,tail = null;
        while(current != null){
            tail = current;
            current = current.nextNode;
        }
        return new Position(tail);
    }
    /**
     * Выводит список на консоль
     */
    public void printList(){
        //цикл от первого элемента списка, пока l не станет равен null
        // В каждой итерации l обновляется ссылкой на следующий элемент в списке: l.nextElement
        //Для каждого элемента списка метод выводит на консоль имя и адрес
        for(Node p = first; p!=null; p = p.nextNode){
            p.PrintElement();
            System.out.println();
        }
    }
}
