package Lab3.Stack.ATDList;
//import  Lab1.ArrayPackage.*;
//import Lab2.CursorList.*;
//import Lab2.DoubleLinkedList.*;
import Lab1.LinkedListPackage.*;

/**
 * Класс реализации стека на АДТ Список.
 * Символы, заносимые в стек размещаются в первой позиции name узла.
 * Заносим символы в начало списка и берм из начала
 */
public class MyStack {

    /**
     * Ссыдка на АТД список
     */
    private final MyList list;

    /**
     * Конструктор стека по умолчанию
     */
    public MyStack() {
        //Создаем экземпляр АТД Списка
        list = new MyList();
    }
    /**
     * Делает стек пустым
     */
    public void makeNull() {
        // Очищаем список
        list.makeNull();
    }

    /**
     * Возвращает элемент (копия) из вершины стека
     * @return копия элемента из вершины стека или null, если стек пустой
     */
    public char top() {
        // Если стек пустой вернем символ 0
        if(isEmpty()) return '\0';
        //Иначе получим элемент в первой позиции списка и вернем первую букву имени
        return list.retrieve(list.first()).name[0];
    }
    /**
     * Удаляет элемент из вершины стека и возвращает его в качестве результата
     * @return элемента из вершины стека или null, если стек пустой
     */
    public char pop() {
        // Если стек пустой вернем символ 0
        if(isEmpty()) return '\0';
        // Получим позицию первого элемента списка
        Position pos = list.first();
        //Запомним символ на первой позиции
        char temp = list.retrieve(pos).name[0];
        // Удалим символ на первой позиции
        list.delete(pos);
        //Вернем сохраненный символ
        return temp;
    }
    /**
     * Вставляет элемент x в вершину стека
     * @param c символ для занесения в стек
     */
    public void push(char c){
        //Создаем элемент Node используя конструктор, который принимает в качестве параметров строку
        // имени и строку адреса. Заносимый символ преобразуем в строку с именем и передадим
        // конструктору элемента Node в качестве имени. Строку с адресом оставим пустой.
        // Занесем этот Node элемент на первую позицию списка
        list.insert(new Node(String.valueOf(c),""),list.first());
    }
    /**
     * Возвращает значение true, если стек пустой, и значение false в противном случае
     * @return true, если стек пустой
     */
    public boolean empty() {
        // Передадим вызов приватному методу
        return isEmpty();
    }

    /**
     * Приватный метод определения пустой стек или нет
     * @return true, если стек пустой
     */
    private boolean isEmpty(){
        //Стек пустой, если список пустой, а он пустой если позиция первого элемента
        // равна позиции после последнего
        return list.first().equals(list.end());
    }
    /**
     * Возвращает значение true, если стек полный, и значение false в противном случае
     * @return true, если стек полный
     */
    public boolean full() {
        // Всегда возвращаем false, так как стек на списке никогда не переполняется, пока есть
        // свободная память в компьютере
        return false;
    }
}
