package Lab4.PriorityQueue.Heap;
import Lab4.PriorityQueueException;

/**
 * Класс реализует функциональность очереди приоритетов на сбалансированном неубывающем двоичном
 * дереве (неубывающей куче)
 */
public class MyPriorityQueue {
    /**
     * Размерность массива для хранения очереди
     */
    private static final int DEFAULT_CAPACITY = 100;
    /**
     * Ссылка на массив для элементов очереди
     */
    private final int[] items;
    /**
     * Текущий размер очереди
     */
    private int size;

    /**
     * Конструктор по умолчанию
     */
    public MyPriorityQueue() {
        // Выделяем память для массива
        items = new int[DEFAULT_CAPACITY];
        // Устанавливаем начальный размер очереди
        size = 0;
    }

    /**
     * Возвращает значение с минимальным приоритетом, при этом удаляя его из очереди
     * @return минимальное число-приоритет
     */
    public int deleteMin() {
        // Проверяем на наличие значений
        if(size == 0 ) throw new PriorityQueueException("Очередь пустая!");
        // возвращаем удаленное значение
        return extractFirst();
    }

    /**
     * Делает очередь пустой
     */
    public void makeNull() {
        // Просто обнуляем размер очереди
        size = 0;
    }

    /**
     * Выводит очередь на экран в порядке правильной очереди, а не в порядке следования
     * элементов в массиве
     * @return
     */
    public void print() {
        // Создадим временную копию кучи
        int[] temp = new int[size];
        // Копируем все элементы во временный массив
        for(int i = 0; i < size; i++){
            temp[i] = items[i];
        }
        // Запоминаем размер очереди
        int tmpSize = size;
        // Печатаем очередь, вытаскивая первый элемент, пока очередь не опустеет
        System.out.println("Очередь: ");

        int item = extractFirst();
        while (size > 0){
            System.out.printf("%d; ", item);
            item = extractFirst();
        }
        System.out.println();

        // Восстановим из копии
        size = tmpSize;
        for(int i = 0; i < size; i++){
            items[i] = temp[i];
        }
    }
    //Методы для работы с heap

    /**
     * Вставляем элемент в кучу
     * @param pr вставляемый приоритет
     */
    public void insert(int pr) {
        // Проверяем, что есть место в массиве
        if(size == items.length) throw new PriorityQueueException("Очередь полная!");
        // Заносим новый элемент на позицию после последнего элемента
        items[size] = pr;
        // Если элементов больше одного, то производим перестроение дерева,
        // поднимая занесенный элемент по дереву вверх
        if(size > 0)  {
            heapifyUp(size);
        }
        // Увеличиваем счетчик занесенных элементов
        size++;
    }

    /**
     * Приватный метод удаления элемента с вершины кучи (двоичного дерева)
     * @return Элемент, который был на вершине
     */
    private int extractFirst() {
        // Если очередь пустая, вернем минимальное целое число
        if(size == 0) return Integer.MIN_VALUE;
        //Запоминаем элемент в вершине дерева - на 0-ой позиции в массиве
        int temp = items[0];
        //уменьшаем количество элементов в массиве (дереве),
        // Заносим элемент с последней позиции (самый последний лист дерева)
        // на 0-ую позицию (в вершину дерева).
        items[0] = items[--size];
        // Элемент в вершине получится
        // гарантированно не менее значений в листах, запустим механизм
        // опускания вершины по дереву
        heapifyDown(0);
        // Вернем запомненный элемент из вершины
        return temp;
    }

    /**
     * Метод вычисляет индекс родительского элемента для листа
     * @param i индекс листа
     * @return индекс родителя
     */
    private int parent(int i) {
        return (i - 1) / 2;
    }

    /**
     * Метод вычисляет индекс левого листа для узла
     * @param i индекс узла
     * @return индекс левого листа
     */
    private int leftChild(int i) {
        return 2 * i + 1;
    }

    /**
     * Метод вычисялет индекс правого листа для узла
     * @param i индекс узла
     * @return индекс правого листа
     */
    private int rightChild(int i) {
        return 2 * i + 2;
    }

    /**
     * Метод меняет местами значения по указанным индексам
     * @param i первый индекс
     * @param j второй индекс
     */
    private void swap(int i, int j) {
        int temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    /**
     * Метод поднимает элемент по дереву вверх, соблюдая правило не убывания двоичного дерева
     * @param pos индекс поднимаемого элемента
     */
    private void heapifyUp(int pos) {
        //Организуем цикл до тех пор, пока индекс больше 0
        // и элемент по тому индексу меньше родителя
        while (pos > 0 && items[pos] < items[parent(pos)]) {
            // Поменяем местами значение листа с родителем
            swap(pos, parent(pos));
            // Установим индекс равным индексу родителя
            pos = parent(pos);
        }
    }

    /**
     * Метод опускает элемент по дереву вниз, соблюдая правило не убывания двоичного дерева
     * @param pos индекс опускаемого элемента
     */
    private void heapifyDown(int pos) {
        // Организуем цикл до тех пор, пока индекс правого листа находится в пределах элементов
        // очереди
        //Проверяем, что значение узла больше одного из его листов
        //Если значение меньше листьев, то выходим из цикла
        while (rightChild(pos) < size
                && (items[pos] > items[leftChild(pos)] || items[pos] > rightChild(pos))) {
            // Вычислим индекс правого и левого листа для узла
            int left = leftChild(pos);
            int right = rightChild(pos);
            //В случае если первый лист меньше второго, то меняем значение с первым листом
            if (items[left] <items[right]) {
                 swap(left, pos);
                 // Устанавливаем значение индекса узла на индекс этого листа
                 pos = left;
            }
            //Иначе меняем со вторым листом
            else {
                 swap(right, pos);
                 pos = right;
            }
        }
    }
}
